BitSense: Universal and Nearly Zero-Error Optimization for Sketch Counters with Compressive SensingRui Ding, Shibo Yang, Xiang Chen, and Qun HuangPeking UniversityABSTRACT1 INTRODUCTIONSketch algorithms have been widely deployed for network measurement as they achieve high accuracy with restricted resource usage. They store measurement results compactly in fixed-size counters. However, as sketch counters are skewed towards low values, higher bits in most counters remain zero. Such massive unused bits impair the space efficiency valued by sketch algorithms. Unfortunately, efforts to mitigate the issue either apply to specific algorithms or compromise accuracy. In this paper, we design BitSense, a novel optimization framework that integrates with existing sketch algorithms. The key idea is to regard higher bits in sketch counters as a sparse vector and leverage compressive sensing techniques to compress and restore counters. Further, BitSense provides a programming model to help developers easily realize sketch algorithms without dealing with the details of compression and recovery. BitSense proposes an automatic approach for parameter configuration. It theoretically guarantees nearly zero error under the configuration. We have built a BitSense prototype in P4 and a software platform and integrated it with fourteen sketch solutions. Extensive experiments show that BitSense significantly reduces the memory usage of existing sketch solutions by 25%-80% while incurring little overhead and almost zero accuracy drop, outperforming five state-of-the-art optimization frameworks.Network measurement forms the cornerstone of many important network management tasks, such as traffic engineering [32, 49, 70,78], performance diagnosis [1, 2, 22, 33, 39, 79], and anomaly detection [45, 71]. It collects comprehensive traffic statistics to characterize network dynamics. Among existing measurement techniques a broad family of probabilistic algorithms, namely sketch, has attracted much attention. Sketch algorithms achieve high accuracy with restricted resource usage [66]. Specifically, a sketch stores measurement results (e.g., per-flow frequencies) in fixed-size counters. When a packet arrives, it extracts the flowkey, which is defined as a combination (e.g., 5-tuple) of header fields in the packet. It then hashes the key to select counters and updates them accordingly. When querying flow statistics, the sketch yields an accurate estimate based on its counters.CCS CONCEPTS·Networks→ Network measurement;However, given heavier traffic [49] and more diverse measurement tasks [50], sketches must scale in size to maintain an acceptable error level. This trend poses a challenge to high-speed switching hardware, which has limited on-chip memory space due to physical constraints [58]. To resolve this issue, we observe that sketch counters suffer from the implicit waste, i.e., higher bits of most counters are zero and lead to the waste. The waste is prevalent since existing sketches allocate fixed-size counters long enough to hold the maximum value. The skewness in network traffic further aggravates the issue: Counters are biased towards low values as only a small fraction of flows are largeKEYWORDSNetwork Measurement; Sketch; Compressive SensingACM Reference Format:Rui Ding, Shibo Yang, Xiang Chen, and Qun Huang. 2023. BitSense: Universal and Nearly Zero-Error Optimization for Sketch Counters with Compressive Sensing. In ACM SIGCOMM 2023 Conference (ACM SIGCOMM23), September 10-14, 2023, New York, NY, USA. ACM, New York, NY, USA,19 pages. https://doi.org/10.1145/3603269.3604865Qun Huang is the corresponding author.Unfortunately, prior studies primarily focus on improving the trade-off between accuracy and memory usage by designing new algorithms [4, 5, 21, 55, 59, 61], They rarely address the implicit waste in sketch counters. Even though some methods intend to compress counters [12, 46, 53, 65, 68], they have three limitations. First, they reduce storage resources at the cost of losing accuracy [12, 68], which compromises the quality of measurement results. Second, they are crafted for specific data structures and fail to generalize to other sketches [46, 53, 65]. Third, they are not adaptive to flow characteristics: Some frameworks are efficient under highly skewed traffic and yet futile under a uniform distribution [42]. In summary, improving the space efficiency of sketch algorithms and adapting to diverse traffic characteristics remain critical and challenging issues.Permission to make digital or hard copies of all or part of this work for personal or classroom use is oranted without fee nrovided that conies are not made or distrihuted for profit or commercial advantage and that copies bear this notice and the full citation on the first nage. Conyrights for comnonents of this work owned hy others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, reauires prior specific permission and/or a fee Remuest nermissions from nermissions@acm orgl ACM SIGCOMM '23, September 10-14, 2023, New York, NY, USA © 2023 Copyright held by the owner/author(s). Publication rights licensed to the Aeeociation for Computing MachineryACM ISBN 979-8-4007-0236-5/23/09...$15.00https://doi.org/10.1145/3603269.3604865In this paper, we present BitSense, a novel optimization framework that removes implicit waste in sketch counters. Its key idea is to regard higher bits of counters as a sparse vector. Hence, BitSense compresses them with a technique, namely compressive sensing. Specifically, BitSense represents each counter with several shorter counters, which we call segments. With the implicit waste of counters, most segments are zero, forming a sparse vector. BitSense exploits the sparsity by compressing these segments with compressive sensing in the data plane and recovering them in the control ACM SIGCOMM '23, September 10-14, 2023, New York, NY, USAΝDing et al.plane. The recovery solves an optimization problem. Compressive sensing theory ensures that the restored counters are almost identical to the original ones, which implies nearly zero accuracy drop.LdCCM+DTFR→NS◆SL+UM10°10-3BitSense also provides an estimation method in the data plane to enable real-time query. The key idea is to record the overflow of segments in a tiny auxiliary sketch. Since overflow rarely occurs, the auxiliary sketch occupies minimal memory. BitSense leverages the auxiliary sketch to estimate counters without solving optimization problems. Compared to the recovery, the estimation provides a looser accuracy guarantee. Fortunately, as well-approximated estimates suffice to produce solid answers for sketches, the estimation does not compromise the overall measurement quality.10-615Position of a bit, pFigure 1: Counter distribution in six selected sketches.BitSense addresses the limitations of prior art in three aspects. First, we propose an approach that automatically sets its parameters to avoid accuracy loss. Theoretical analysis guarantees nearly zero error under such configurations. Second, for universality, BitSense seamlessly integrates with the workflow of existing sketch frameworks. It provides an abstraction of sketch counters (i.e., BSCnt) to conceal the low-level details of the compression and recovery. Finally, for adaptability, BitSense robustly reduces storage under diverse sketching data structures and traffic characteristics. It also incurs limited resource overhead.sketches, namely Count-min sketch (CM) [16], Deltoid (DT) [18], FlowRadar (FR) [38], Nitrosketch (NS) [43], SketchLearn (SL) [29] and UnivMon (UM) [44]. To mitigate noise, we run each sketch with different hash seeds a hundred times. Figure 1 depicts the counter distributions, which are all heavy-tailed as their tail probability decreases almost linearly in the log-log plot. Moreover, the entropy of sketch counters is less than 7.5, while the binary length of the maximum value is over 15. These numbers indicate the severity of implicit waste. Consequently, sketch algorithms incur a higher memory usage than they actually need.2.2 Related WorkWe build a prototype of BitSense in P4 and a software platform. We also integrate it with fourteen sketch algorithms to demonstrate its broad applicability. Experiments show that BitSense enables sketch algorithms to achieve the same accuracy with only 25%-80% of the original storage while incurring little overhead. BitSense outperforms five state-of-the-art sketch optimization frameworks.The source code of our BitSense prototype is now available at https://github.com/N2-Sys/BitSense. This work does not raise any ethical issues.Variable-width counters. One straightforward solution to reduce implicit waste is to employ variable-width counters [3, 15, 20, 24, 27] For example, we can start from small counters and add extra bits on an overflow (e.g., by merging with short counters). Unfortunately, variable-width counters are infeasible in the high-speed data plane for two reasons. First, addressing such counters is computationally prohibitive. For example, SALSA [3] has to check several merge bits to determine the boundary of a single counter. Second, counter expansion may move or resize other counters, resulting in a costly cascading effect.2 BACKGROUND AND RELATED WORK2.1 Implicit Waste of CountersThis paper aims to optimize sketch counters, which store flow states compactly to fit in the restricted switch memory [29, 30]. Still, switch memory becomes one bottleneck of sketch deployment for three reasons. (i) Rapid traffic growth drives the need for massive counters, which can surpass the memory budget [49]. (ii) Diversity of measurement tasks leads to the co-location of multiple sketches at one switch, reducing each sketch's memory budget [50]. (iii) The amount of on-chip memory is severely limited (e.g., tens of MB) due to global power and speed constraints [58]. To resolve this issue, we observe that counters suffer from the implicit waste, i.e., a large proportion of bits remain zero. Two reasons account for this fact. (i) Sketch counters are typically fixed-size. They should contain enough bits to avoid overflow [3]. Since the maximum value is orders of magnitude larger than the average (see below), the amount of waste is enormous. (ii) A large counter has to associate with either a large flow or a host of small flows. However, either case rarely occurs. First, the ubiquitous skewness of network traffic indicates that large flows are few [17]. Second, the random nature of sketch algorithms precludes frequent hash conflicts of small flows [30]. Therefore, higher bits in most counters are unused.Cache-assisted methods. In a hybrid SRAM-DRAM memory design, the fast SRAM caches small-sized counters and occasionally flushes them to larger counters in DRAM [54, 56, 73]. However, the design has two severe drawbacks: (i) it incurs costly SRAMto-DRAM updates, and (ii) the counter management algorithm is hard to implement due to the limited capacity of SRAM. CASE [40] exploits the heavy tail by counting large flows' packets in SRAM and writing back based on estimators during cache replacement. However, it incurs significant accuracy loss.Hybrid sketch methods. Such solutions attempt to combine the strength of two distinct algorithms by proposing a hybrid structure to efficiently use the counters [28, 63, 72, 74]. Elastic sketch [66] traces large flows in a hash table and residual flows in CM. MC sketch [41] maintains a fine and a coarse part based on the flow's priority. DHS [72] records large flows with longer fingerprints than small flows, thus monitoring at a finer granularity. However, these methods coarsely separate large counters from small ones. In each dedicated data structure, implicit waste still prevails.We further validate our observation via benchmark analysis. We insert packets in a captured CAIDA trace [7] into six heterogeneousCounter sharing schemes. In such schemes, parts of the counters share a common on-chip address, which reduces the memory footprint. They rely on decoding methods to restore counter values. For example, Counter Braids [46, 47] decodes with a message-passing algorithm. One grave drawback is that it can yield highly biased or even meaningless estimates given tight memory. Other decoding methods rely on unbiased estimators [12, 37]. Unfortunately, these meticulously crafted estimators have a huge variance, rendering the final estimates unbiased yet varied. Segment 0Segment 1Segment 2Segment 3Control PlaneFixed-size countersBSCntoverflowoverflowoverflow=270م6(27-31(6-2isomorphic27%226%221%220(1) DevelopFigure 2: Representing a BSCnt of value 27 with four two-bit segments.UserRaw SketchRestored SketchHierarchical structure. Other methods leverage a hierarchical structure to facilitate space reduction with high accuracy [35, 68]. Generally, they record an overflow from a lower layer in the next and introduce some mechanisms to mark its presence. FCM sketch [60] associates an indicator with each counter. One Memory sketch [77] stores a fingerprint of the overflowed flows. Bloom sketch [76] records the overflowed flows in Bloom Filters. Diamond sketch [65] tracks the overflow depth of each flow in a designated carry part. These techniques are designed for specialized algorithms. In contrast, BitSense is a universal framework applicable to heterogeneous sketch algorithms.2) Transform4) Restorelower / higher segments3) UpdatePacketsAuxiliary sketch(For online estimation)Data PlaneTransformed SketchFigure 3: BitSense architecture.3 DESIGN OF BITSENSEcan hold the value one; hence, it stores this value and produces no overflow. Segment 3 is unmodified, hence zero. Since high segments are used less frequently than low segments, they tend to be sparse and lead to compression opportunities.BitSense is a universal and nearly zero-error optimization framework for sketch counters with several design goals:Memory efficiency: It efficiently eliminates implicit waste in sketch counters.Universality: It seamlessly integrates with existing sketch algorithms. When integrating with multiple sketches simultaneously, BitSense can measure different traffic statistics.Nearly zero error: It restores each counter with nearly zero error after compression; hence, it will not compromise the measurement accuracy.Segment-based compression. BitSense exploits the sparsity of higher segments to reduce memory usage. Specifically, BitSense leverages compressive sensing, a technique adequate for compressing and restoring a sparse vector [8, 13, 14] to compress higher segments. It cuts down the number of higher segments. Accordingly, each higher segment no longer stores an individual overflow (from a lower segment) but the sum of multiple overflows (from different lower segments). BitSense modifies related segments when an incoming packet updates a BSCnt.Robustness: It is space-efficient for diverse flow patterns.Limited overhead: It incurs limited resource overhead.User-friendliness: It provides a clean interface to users.3.1 Design OverviewAbstraction. BitSense provides a library that contains a new type of counter, namely BSCnt, to conceal the low-level details of eliminating implicit waste. Each BSCnt logically represents a fixed-size counter, while BitSense will compress their higher bits in the data plane and recover their values when answering queries. The compression and recovery processes are transparent to users. BSCnt supports basic counter operations such as increment and real-time value access via its interfaces. As $3.2 shows, BitSense realizes complex counter operations by composing basic BSCnt interfaces. Hence, BitSense can integrate with existing sketch algorithms by replacing their counter operations with BSCnt interfaces.Optimization-based recovery. BitSense restores the compressed counters by solving an optimization problem in the control plane. Since compression obscures the information of an individual overflow, the optimization-based recovery aims to restore as many overflows as possible. However, as high segments are much fewer than the potential overflows, perfectly restoring each overflow is generally infeasible. Fortunately, the compressive sensing theory guarantees that the restored counters are nearly identical to the original ones with the sparsity of high segments [9, 10].Segment. Under the hood, BitSense represents a BSCnt with several short counters ordered from low to high, which we call segments. Such representation is similar to the decimal representation of a number, where each segment acts like one digit. Specifically, when the value of BSCnt is too large to hold in a short segment, the segment produces an overflow, and a high segment stores this overflow. For example, suppose BitSense represents a BSCnt of value 27 with four two-bit segments (Figure 2). Segment 0 holds the value 27%22 = 3 and produces an overflow of (27-3)/22 = 6. Segment 1 cannot hold the value six; hence, it stores the value 6%22 = 2 and produces an overflow of (6- 2)/22 = 1. Segment 2Online estimation. When we try to retrieve a counter in the data plane, solving an optimization problem is computationally prohibitive. Therefore, BitSense allows estimating the counter value directly in the data plane. The key idea is to equip BitSense with an auxiliary sketch that records the overflows of the lowest segments. It takes advantage of the accuracy guarantee and relatively low overhead of the auxiliary sketch to estimate overflow values accurately and quickly. Compared to the control-plane recovery, online estimation provides a looser accuracy guarantee but has higher speed and less computation. Our experiments show that online estimation does not degrade the overall measurement quality (S6.2). We also wrap the online estimation as an interface of BSCnt to conceal the details of the auxiliary sketch from users (S3.2).Autoconfiguration. BitSense automatically configures its parameters of the compression and recovery phases plus the auxiliary sketch. Its configuration accounts for the underlying sketch structures and traffic characteristics, making it robust against diverse traffic patterns (S6.3). Furthermore, we theoretically show that the configuration achieves nearly zero-error recovery with low access and hash overheads ($4). Architecture. BitSense consists of a data plane and a control plane, as recent studies in software-defined measurement [26, 60, 69, 70]. Its workflow contains four steps (Figure 3).Param: A table T with m slots, either containing (ki, vi) at slot i or empty. Input:Flowkey k, packet size v, threshold value of heavy hitters H.> Space-saving algorithm>Raw space-saving algorithm(1) Develop ($3.2): Given the telemetry purpose, users develop a sketch algorithm (referred to as the raw sketch) using the BSCnt library.// Data plane// Data planeprocedure UPDATE(k v)procedure UPDATE(k, v)if 3 slot i in T with k = k; thenif 3 slot i in T with k = ki thenV:V:VADD(T.vi,v)(2) Transform ($3.3): BitSense control plane transforms the raw sketch by reducing the number of high segments. It also appends an auxiliary sketch if online estimation is needed (justified by code analysis).else if 3 empty slot i in T thenelse if 3 empty slot i in T then(ki,vi) ← (k,vi+v)ki ← k; ADD(T.vi,v)elseelsej ← argmin; vij←argmin, EST(T.vi)(kj,vi)←(k,vi+v)kj ←k; ADD(T.vj,v)(3) Update (S3.4): Packets update BSCnts via the data plane interfaces, which internally modify the transformed sketch, including the segments and the auxiliary sketch (if there is any).// Control plane// Control planeprocedure HEAVY HITTERS(H)procedure HEAVY_HITTERS(H)S←0وs(4) Restore ($3.5): Data plane periodically reports the transformed sketch to the control plane, which restores the counters by solving an optimization problem. The output of the recovery phase is a restored sketch structurally isomorphic to the raw sketch. Applications query the restored sketch to obtain the intended traffic statistics.for each slot i in T dofor each slot i in T doif vi > H thenui←GET(T.vi)Add (ki, vi) to Sif u > H thenreturnSAdd (ki, ui) to Sreturn SFigure 4: A use case of the basic interfaces.Discussion. We adopt compressive sensing for its theoretical accuracy guarantee, efficient hardware-friendly compression, and robustness to noise [8, 13, 14]. Although prior work [13, 30, 34] also leverages compressive sensing to measure flow patterns, our work significantly differs in two aspects. First, we show how to remove implicit waste with compressive sensing, while prior work focuses solely on accurate measurement. Second, our solution is integrable with existing sketches to improve their space efficiency, which is beyond a standalone sketch solution.BitSense requires no knowledge of the algorithm's high-level design. Therefore, BitSense is integrable with existing sketch algorithms via a clean abstraction of the fixed-size counters. Henceforth we also refer to each BSCnt as a counter since there is no confusion.3.3 Transform: Data Structure3.2 Develop: BSCnt and its InterfacesBitSense defines BSCnt as a structure of the C language style. Users build arrays or matrices with BSCnt when developing the raw sketch as if they are manipulating regular fixed-size counters. BSCnt supports three interfaces:add(BSCnt, val)est (BSCnt)The transformation turns a raw sketch into a space-efficient structure. Assume that a raw sketch has no counters. BitSense represents each counter with L segments, where Segment l contains bi bits (0 ≤l <L-1). Segment l from all the counters collectively forms a layer, hence there are L layers. Moreover, BitSense views all Layerl segments as a linear array to provide a uniform data structure for compression. Figure 5(a) illustrates how BitSense transforms a 2 × 3 Count-Min sketch whose no = 6. BitSense represents each counter with L = 3 segments, as shown by horizontally aligned blocks in the figure. Further, a layer comprises the six vertically aligned segments.get (BSCnt)Specifically, add updates a BSCnt by the specified value. There is no constraint on the sign of the value; hence increasing and decreasing are both supported. The est interface returns the online estimate of a BSCnt in the data plane. The get interface returns the restored value of a counter in the control plane, which guarantees nearly zero accuracy dropBitSense transforms the raw sketch in three aspects. First, it cuts the number of high segments. Second, it attaches a status bit to a segment. Third, it appends an auxiliary sketch.Composition of the interfaces. BitSense supports complex counter operations in the data plane by composing the add and est interfaces. For example, we consider resetting a counter to zero. We do it by first obtaining an estimate v of the counter via est and then updating the counter by -v via add. Appendix A summarizes a four-step mechanical rule for implementing complex operations. It further exemplifies the rule with three examples: divisions, assignments, and comparisons.Reduced segments. BitSense cuts the number of segments in Layer l > 0 down to n (< n_1). Accordingly, each segment no longer stores an individual overflow as in Figure 5(a), but the sum of multiple overflows. We call the sum of multiple overflows as a sample, a term borrowed from the compressive sensing literature. Specifically, a Layer-l segment stores a sample's lowest b bits. If a sample is too large to fit in a segment, its higher bits will be the overflow, which is the ingredient of Layer-(l + 1) samples. As an illustration, Figure 5(b) shows the transformed sketch where n1 = 3 and n2 = 1. Layer 0 compresses six overflows into three samples, each stored in a Layer-1 segment. Layer 2 further compresses the Layer-1 overflows into just one sample.Example. Figure 4 demonstrate the usage of BSCnt with the spacesaving algorithm [48]. We show the original algorithm on the left and the transformed algorithm on the right for comparison. Note that BitSense only replaces counter operations with the respective interfaces. Other parts of the sketch algorithm remain intact becauseStatus bit. Status bit is one bit associated with each segment to indicate whether the segment has overflowed. Since the counter values are skewed, we expect most status bits to be unset. An unset bit implies that the segment never overflows. It will facilitate the recovery afterward. Note that Layer-(L - 1) segments do not have this bit. The reason is that they must not overflow; otherwise, Layer 0: Layer 1Layer 2Input: Layer I, segment index j, value oMSoo90uLayer 0Layer 0Auxiliary sketchhi(j)=j%2, h2(i)=0Layer 1hi(j) = 0Layer 1Layer 2Auxiliary sketchh(j) = j%2(a) Hash functions used in the example.0Ι0auxilian(k,v)=(0,1),auxiliaryb2sketch+5→sketchbibo bitsb bits b2 bits(a) Representation of the raw sketch in (b) Data structure of the transformed three layerssketch. bostatus bits(b) Increase Counter 2 by two.(c) Increase Counter 0 by five. uiliaryauxiliary (k,v)=(1,-3) sketchsketch +16→(k,v)=(1,4)Figure 5: Sketch transformation.  A block indicates a segment.  A black arrow indicates an overflow, while a red arrow indicates a sample.  Trapezoids represent the scheme of mapping overflows to samples ($3.4).(d) Increase Counter 1 by sixteen.(e) Decrease Counter 1 by nine. Algorithm 1 BitSense add InterfaceFigure 6: An example of BitSense updates. layer I1: procedure UPDATE(l, i, o)layer 0C[i]←(C[il+0) %2bi►Update a segmentlayer 1 auxiliary sketchlayer 0auxiliary sketchif the addition overflows by u t O thenSet the status bit of this segment(a) The add interface.(b) The est interface. if BitSense has auxiliary sketch and l equals 0 then Insert 〈j, u〉to the auxiliary sketch. Figure 7: Data dependency in the data plane. for each hash functions hi in layer I do i←hiSelect an affected sample UPDATE(l + 1, j', u)►Update the sample10: procedure ADD(BSCnt, val)1Determine the linear index j of BSCnt. UPDATE(0, j, val)>Start from layer 0Algorithm 2 BitSense est InterfaceOutput: Estimated valueMapping overflows to samples.  BitSense compresses the overflows from each layer into fewer samples via a hash-based scheme.  Specifically, BitSense designates a few (e.g., three) hash functions in Layer l. Each hash function maps a Layer-l segment to a Layer(l+1) segment.  As long as a Layer-l segment overflows, we add the overflow to every mapped sample.  As the number of hash functions is small, the number of mapped samples is also restricted. 1: procedure EST(BSCnt)Determine the linear index j of BSCnt.  n←Coil if the status bit of Colil is set thenoverflow ← queried result of the auxiliary sketch on key i ច← + overflow .  2bThe add interface.  Internally, add manipulates all the segments corresponding to a BSCnt.  It starts from the lowest segment.  If an overflow occurs, it further updates higher-layer segments that store the mapped samples.  It also maintains the associated status bit and auxiliary sketch. return Ùthere is no layer to store the overflow value.  Existing measurement frameworks have a similar requirement that each counter should be long enough to avoid overflow [3, 46]. 